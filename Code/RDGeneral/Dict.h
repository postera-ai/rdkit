//
// Copyright (C) 2003-2020 Greg Landrum and Rational Discovery LLC
//
//  @@ All Rights Reserved @@
//  This file is part of the RDKit.
//  The contents are covered by the terms of the BSD license
//  which is included in the file license.txt, found at the root
//  of the RDKit source tree.
//
/*! \file Dict.h

  \brief Defines the Dict class

*/
#include <RDGeneral/export.h>
#ifndef RD_DICT_H_012020
#define RD_DICT_H_012020

#include <map>
#include <mutex>
#include <string>
#include <unordered_map>
#include <vector>
#include "RDValue.h"
#include "Exceptions.h"
#include <RDGeneral/BoostStartInclude.h>
#include <boost/lexical_cast.hpp>
#include <RDGeneral/BoostEndInclude.h>

namespace RDKit {
typedef std::vector<std::string> STR_VECT;

//! \brief The \c Dict class can be used to store objects of arbitrary
//!        type keyed by \c strings.
//!
//!  The actual storage is done using \c RDValue objects.
//!
class RDKIT_RDGENERAL_EXPORT Dict {
 private:
   struct InternalPair {
    std::uint16_t key;
    RDValue val;

    InternalPair() : key(0), val() {}  // TODO: should we remove this?
    explicit InternalPair(std::uint16_t k) : key(k), val() {}
    InternalPair(std::uint16_t k, const RDValue &v) : key(k), val(v) {}
  };

  typedef std::vector<InternalPair> InternalDataType;

 public:
  static std::mutex& get_mu() {
    static std::mutex mu;
    return mu;
  }
  static std::unordered_map<std::string, std::uint16_t>& get_strkey_to_key() {
    static std::unordered_map<std::string, std::uint16_t> _strkey_to_key;
    return _strkey_to_key;
  }
  static std::vector<std::string>& getc_key_to_strkey() {
    // length 110.
    static std::vector<std::string> _key_to_strkey = {
      "2D",
      "BalabanJ",
      "BalanbanJ",
      "Discrims",
      "DistanceMatrix_Paths",
      "MRV SMA",
      "MolFileComments",
      "MolFileInfo",
      "NullBond",
      "_2DConf",
      "_3DConf",
      "_AtomID",
      "_BondsPotentialStereo",
      "_CIPCode",
      "_CIPRank",
      "_ChiralityPossible",
      "_CrippenLogP",
      "_CrippenMR",
      "_GasteigerCharge",
      "_GasteigerHCharge",
      "_MMFFSanitized",
      "_MolFileAtomQuery",
      "_MolFileBondAttach",
      "_MolFileBondCfg",
      "_MolFileBondEndPts",
      "_MolFileBondQuery",
      "_MolFileBondStereo",
      "_MolFileBondType",
      "_MolFileChiralFlag",
      "_MolFileRLabel",
      "_Name",
      "_NeedsQueryScan",
      "_QueryFormalCharge",
      "_QueryHCount",
      "_QueryIsotope",
      "_QueryMass",
      "_ReactionDegreeChanged",
      "_RingClosures",
      "_SLN_s",
      "_SmilesStart",
      "_StereochemDone",
      "_TraversalBondIndexOrder",
      "_TraversalRingClosureBond",
      "_TraversalStartPoint",
      "_TriposAtomType",
      "_Unfinished_SLN_",
      "_UnknownStereo",
      "__computedProps",
      "_brokenChirality",
      "_canonicalRankingNumbers",
      "_connectivityHKDeltas",
      "_connectivityNVals",
      "_crippenLogP",
      "_crippenLogPContribs",
      "_crippenMR",
      "_crippenMRContribs",
      "_displayLabel",
      "_displayLabelW",
      "_doIsoSmiles",
      "_fragSMARTS",
      "_hasMassQuery",
      "_isotopicHs",
      "_labuteASA",
      "_labuteAtomContribs",
      "_labuteAtomHContrib",
      "_protected",
      "_queryRootAtom",
      "_rgroupAtomMaps",
      "_rgroupBonds",
      "_ringStereoAtoms",
      "_ringStereoWarning",
      "_ringStereochemCand",
      "_smilesAtomOutputOrder",
      "_starred",
      "_supplementalSmilesLabel",
      "_tpsa",
      "_tpsaAtomContribs",
      "_unspecifiedOrder",
      "atomLabel",
      "atomNote",
      "bondNote",
      "dummyLabel",
      "extraRings",
      "internalRgroupSmiles",
      "isImplicit",
      "maxAttachIdx",
      "molAtomMapNumber",
      "molAttchord",
      "molAttchpt",
      "molClass",
      "molFileAlias",
      "molFileValue",
      "molInversionFlag",
      "molLinkNodes",
      "molParity",
      "molReactStatus",
      "molRxnComponent",
      "molRxnExachg",
      "molRxnRole",
      "molSeqid",
      "molStereoCare",
      "molSubstCount",
      "molTotValence",
      "numArom",
      "old_mapno",
      "origNoImplicit",
      "react_atom_idx",
      "ringMembership",
      "smilesSymbol",
      "was_dummy",
    };
    return _key_to_strkey;
  }
  static std::vector<std::string>& getv_key_to_strkey() {
    static std::vector<std::string> _key_to_strkey;
    return _key_to_strkey;
  }

  static std::uint16_t get_key(const std::string &key) {
    if (key.size() >= 2) {
      // Autogenerated from rdkit_dict_trie.ipynb
      switch (key[0]) {
        case '2': {
          if (key == "2D") return 0;
          break;
        }
        case 'B': {
          if (key == "BalabanJ") return 1;
          if (key == "BalanbanJ") return 2;
          break;
        }
        case 'D': {
          if (key == "Discrims") return 3;
          if (key == "DistanceMatrix_Paths") return 4;
          break;
        }
        case 'M': {
          switch (key[1]) {
            case 'R': {
              if (key == "MRV SMA") return 5;
              break;
            }
            case 'o': {
              if (key == "MolFileComments") return 6;
              if (key == "MolFileInfo") return 7;
              break;
            }
          }
          break;
        }
        case 'N': {
          if (key == "NullBond") return 8;
          break;
        }
        case '_': {
          switch (key[1]) {
            case '2': {
              if (key == "_2DConf") return 9;
              break;
            }
            case '3': {
              if (key == "_3DConf") return 10;
              break;
            }
            case 'A': {
              if (key == "_AtomID") return 11;
              break;
            }
            case 'B': {
              if (key == "_BondsPotentialStereo") return 12;
              break;
            }
            case 'C': {
              if (key == "_CIPCode") return 13;
              if (key == "_CIPRank") return 14;
              if (key == "_ChiralityPossible") return 15;
              if (key == "_CrippenLogP") return 16;
              if (key == "_CrippenMR") return 17;
              break;
            }
            case 'G': {
              if (key == "_GasteigerCharge") return 18;
              if (key == "_GasteigerHCharge") return 19;
              break;
            }
            case 'M': {
              if (key == "_MMFFSanitized") return 20;
              if (key == "_MolFileAtomQuery") return 21;
              if (key == "_MolFileBondAttach") return 22;
              if (key == "_MolFileBondCfg") return 23;
              if (key == "_MolFileBondEndPts") return 24;
              if (key == "_MolFileBondQuery") return 25;
              if (key == "_MolFileBondStereo") return 26;
              if (key == "_MolFileBondType") return 27;
              if (key == "_MolFileChiralFlag") return 28;
              if (key == "_MolFileRLabel") return 29;
              break;
            }
            case 'N': {
              if (key == "_Name") return 30;
              if (key == "_NeedsQueryScan") return 31;
              break;
            }
            case 'Q': {
              if (key == "_QueryFormalCharge") return 32;
              if (key == "_QueryHCount") return 33;
              if (key == "_QueryIsotope") return 34;
              if (key == "_QueryMass") return 35;
              break;
            }
            case 'R': {
              if (key == "_ReactionDegreeChanged") return 36;
              if (key == "_RingClosures") return 37;
              break;
            }
            case 'S': {
              if (key == "_SLN_s") return 38;
              if (key == "_SmilesStart") return 39;
              if (key == "_StereochemDone") return 40;
              break;
            }
            case 'T': {
              if (key == "_TraversalBondIndexOrder") return 41;
              if (key == "_TraversalRingClosureBond") return 42;
              if (key == "_TraversalStartPoint") return 43;
              if (key == "_TriposAtomType") return 44;
              break;
            }
            case 'U': {
              if (key == "_Unfinished_SLN_") return 45;
              if (key == "_UnknownStereo") return 46;
              break;
            }
            case '_': {
              if (key == "__computedProps") return 47;
              break;
            }
            case 'b': {
              if (key == "_brokenChirality") return 48;
              break;
            }
            case 'c': {
              if (key == "_canonicalRankingNumbers") return 49;
              if (key == "_connectivityHKDeltas") return 50;
              if (key == "_connectivityNVals") return 51;
              if (key == "_crippenLogP") return 52;
              if (key == "_crippenLogPContribs") return 53;
              if (key == "_crippenMR") return 54;
              if (key == "_crippenMRContribs") return 55;
              break;
            }
            case 'd': {
              if (key == "_displayLabel") return 56;
              if (key == "_displayLabelW") return 57;
              if (key == "_doIsoSmiles") return 58;
              break;
            }
            case 'f': {
              if (key == "_fragSMARTS") return 59;
              break;
            }
            case 'h': {
              if (key == "_hasMassQuery") return 60;
              break;
            }
            case 'i': {
              if (key == "_isotopicHs") return 61;
              break;
            }
            case 'l': {
              if (key == "_labuteASA") return 62;
              if (key == "_labuteAtomContribs") return 63;
              if (key == "_labuteAtomHContrib") return 64;
              break;
            }
            case 'p': {
              if (key == "_protected") return 65;
              break;
            }
            case 'q': {
              if (key == "_queryRootAtom") return 66;
              break;
            }
            case 'r': {
              if (key == "_rgroupAtomMaps") return 67;
              if (key == "_rgroupBonds") return 68;
              if (key == "_ringStereoAtoms") return 69;
              if (key == "_ringStereoWarning") return 70;
              if (key == "_ringStereochemCand") return 71;
              break;
            }
            case 's': {
              if (key == "_smilesAtomOutputOrder") return 72;
              if (key == "_starred") return 73;
              if (key == "_supplementalSmilesLabel") return 74;
              break;
            }
            case 't': {
              if (key == "_tpsa") return 75;
              if (key == "_tpsaAtomContribs") return 76;
              break;
            }
            case 'u': {
              if (key == "_unspecifiedOrder") return 77;
              break;
            }
          }
          break;
        }
        case 'a': {
          if (key == "atomLabel") return 78;
          if (key == "atomNote") return 79;
          break;
        }
        case 'b': {
          if (key == "bondNote") return 80;
          break;
        }
        case 'd': {
          if (key == "dummyLabel") return 81;
          break;
        }
        case 'e': {
          if (key == "extraRings") return 82;
          break;
        }
        case 'i': {
          switch (key[1]) {
            case 'n': {
              if (key == "internalRgroupSmiles") return 83;
              break;
            }
            case 's': {
              if (key == "isImplicit") return 84;
              break;
            }
          }
          break;
        }
        case 'm': {
          switch (key[1]) {
            case 'a': {
              if (key == "maxAttachIdx") return 85;
              break;
            }
            case 'o': {
              if (key == "molAtomMapNumber") return 86;
              if (key == "molAttchord") return 87;
              if (key == "molAttchpt") return 88;
              if (key == "molClass") return 89;
              if (key == "molFileAlias") return 90;
              if (key == "molFileValue") return 91;
              if (key == "molInversionFlag") return 92;
              if (key == "molLinkNodes") return 93;
              if (key == "molParity") return 94;
              if (key == "molReactStatus") return 95;
              if (key == "molRxnComponent") return 96;
              if (key == "molRxnExachg") return 97;
              if (key == "molRxnRole") return 98;
              if (key == "molSeqid") return 99;
              if (key == "molStereoCare") return 100;
              if (key == "molSubstCount") return 101;
              if (key == "molTotValence") return 102;
              break;
            }
          }
          break;
        }
        case 'n': {
          if (key == "numArom") return 103;
          break;
        }
        case 'o': {
          switch (key[1]) {
            case 'l': {
              if (key == "old_mapno") return 104;
              break;
            }
            case 'r': {
              if (key == "origNoImplicit") return 105;
              break;
            }
          }
          break;
        }
        case 'r': {
          switch (key[1]) {
            case 'e': {
              if (key == "react_atom_idx") return 106;
              break;
            }
            case 'i': {
              if (key == "ringMembership") return 107;
              break;
            }
          }
          break;
        }
        case 's': {
          if (key == "smilesSymbol") return 108;
          break;
        }
        case 'w': {
          if (key == "was_dummy") return 109;
          break;
        }
      }
    }

    std::lock_guard<std::mutex> guard(get_mu());
    auto& _strkey_to_key = get_strkey_to_key();
    auto it = _strkey_to_key.find(key);
    if (it != _strkey_to_key.end()) {
      return it->second;
    }

    auto& _key_to_strkey = getv_key_to_strkey();
    std::uint16_t new_key = 110 + _strkey_to_key.size();
    _strkey_to_key.emplace_hint(it, key, new_key);
    _key_to_strkey.push_back(key);

    // Intentionally keep this log statement in here,
    std::cout << "UNHANDLED Dict::get_key: INSERTING <" << key << "> as " << new_key << std::endl;

    return new_key;
  }

  static std::string get_strkey(std::uint16_t key) {
    if (key < 110) {
      return getc_key_to_strkey()[key];
    }
    key -= 110;

    std::lock_guard<std::mutex> guard(get_mu());
    const auto& _key_to_strkey = getv_key_to_strkey();
    return _key_to_strkey[key];
  }

  // Legacy external-facing interfaces.
  // Not used internally.
  struct Pair {
    std::string key;
    RDValue val;

    Pair() : key(), val() {}
    explicit Pair(std::string s) : key(std::move(s)), val() {}
    Pair(std::string s, const RDValue &v) : key(std::move(s)), val(v) {}
  };
  typedef std::vector<Pair> DataType;

  Dict()  {}

  Dict(const Dict &other) : _data(other._data) {
    InternalDataType data(other._data.size());
    _data.swap(data);
    for (size_t i = 0; i < _data.size(); ++i) {
      _data[i].key = other._data[i].key;
      copy_rdvalue(_data[i].val, other._data[i].val);
    }
  }

  ~Dict() {
    reset();  // to clear pointers if necessary
  }

  void update(const Dict &other, bool preserveExisting = false) {
    if (!preserveExisting) {
      *this = other;
    } else {
      for (size_t i = 0; i < other._data.size(); ++i) {
        const InternalPair &pair = other._data[i];
        InternalPair *target = nullptr;
        for (size_t i = 0; i < _data.size(); ++i) {
          if (_data[i].key == pair.key) {
            target = &_data[i];
            break;
          }
        }

        if (!target) {
          // need to create blank entry and copy
          _data.push_back(InternalPair(pair.key));
          copy_rdvalue(_data.back().val, pair.val);
        } else {
          // just copy
          copy_rdvalue(target->val, pair.val);
        }
      }
    }
  }

  Dict &operator=(const Dict &other) {
    if (this == &other) return *this;
    reset();

    InternalDataType data(other._data.size());
    _data.swap(data);
    for (size_t i = 0; i < _data.size(); ++i) {
      _data[i].key = other._data[i].key;
      copy_rdvalue(_data[i].val, other._data[i].val);
    }
    return *this;
  }

  //----------------------------------------------------------
  //! \brief Access to the underlying data.
  const DataType getData() const {
    DataType result;
    for (const auto& it : _data) {
      std::string strkey = Dict::get_strkey(it.key);
      result.push_back(Pair(strkey, it.val));
    }
    return result;
  }
  DataType getData() {
    DataType result;
    for (const auto& it : _data) {
      std::string strkey = Dict::get_strkey(it.key);
      result.push_back(Pair(strkey, it.val));
    }
    return result;
  }

  //----------------------------------------------------------

  //! \brief Returns whether or not the dictionary contains a particular
  //!        key.
  bool hasVal(const std::string &what) const {
    std::uint16_t key = get_key(what);
    for (const auto &data : _data) {
      if (data.key == key) return true;
    }
    return false;
  }
  bool hasVal(const std::uint16_t &key) const {
    for (const auto &data : _data) {
      if (data.key == key) return true;
    }
    return false;
  }

  //----------------------------------------------------------
  //! Returns the set of keys in the dictionary
  /*!
     \return  a \c STR_VECT
  */
  STR_VECT keys() const {
    STR_VECT res;
    res.reserve(_data.size());
    for (const auto &item : _data) {
      res.push_back(get_strkey(item.key));
    }
    return res;
  }

  //----------------------------------------------------------
  //! \brief Gets the value associated with a particular key
  /*!
     \param what  the key to lookup
     \param res   a reference used to return the result

     <B>Notes:</b>
      - If \c res is a \c std::string, every effort will be made
        to convert the specified element to a string using the
        \c boost::lexical_cast machinery.
      - If the dictionary does not contain the key \c what,
        a KeyErrorException will be thrown.
  */
  template <typename T>
  void getVal(const std::string &what, T &res) const {
    res = getVal<T>(what);
  }
  template <typename T>
  void getVal(const std::uint16_t &key, T &res) const {
    res = getVal<T>(key);
  }

  //! \overload
  template <typename T>
  T getVal(const std::string &what) const {
    std::uint16_t key = get_key(what);
    for (auto &data : _data) {
      if (data.key == key) {
        return from_rdvalue<T>(data.val);
      }
    }
    throw KeyErrorException(what);
  }
  template <typename T>
  T getVal(const std::uint16_t &key) const {
    for (auto &data : _data) {
      if (data.key == key) {
        return from_rdvalue<T>(data.val);
      }
    }
    std::string what = get_strkey(key);
    throw KeyErrorException(what);
  }

  //! \overload
  void getVal(const std::string &what, std::string &res) const {
    std::uint16_t key = get_key(what);
    for (const auto &i : _data) {
      if (i.key == key) {
        rdvalue_tostring(i.val, res);
        return;
      }
    }
    throw KeyErrorException(what);
  }
  void getVal(const std::uint16_t &key, std::string &res) const {
    for (const auto &i : _data) {
      if (i.key == key) {
        rdvalue_tostring(i.val, res);
        return;
      }
    }
    std::string what = get_strkey(key);
    throw KeyErrorException(what);
  }

  //----------------------------------------------------------
  //! \brief Potentially gets the value associated with a particular key
  //!        returns true on success/false on failure.
  /*!
     \param what  the key to lookup
     \param res   a reference used to return the result

     <B>Notes:</b>
      - If \c res is a \c std::string, every effort will be made
        to convert the specified element to a string using the
        \c boost::lexical_cast machinery.
      - If the dictionary does not contain the key \c what,
        a KeyErrorException will be thrown.
  */
  template <typename T>
  bool getValIfPresent(const std::string &what, T &res) const {
    std::uint16_t key = get_key(what);
    for (const auto &data : _data) {
      if (data.key == key) {
        res = from_rdvalue<T>(data.val);
        return true;
      }
    }
    return false;
  }
  template <typename T>
  bool getValIfPresent(const std::uint16_t &key, T &res) const {
    for (const auto &data : _data) {
      if (data.key == key) {
        res = from_rdvalue<T>(data.val);
        return true;
      }
    }
    return false;
  }

  //! \overload
  bool getValIfPresent(const std::string &what, std::string &res) const {
    std::uint16_t key = get_key(what);
    for (const auto &i : _data) {
      if (i.key == key) {
        rdvalue_tostring(i.val, res);
        return true;
      }
    }
    return false;
  }
  bool getValIfPresent(const std::uint16_t &key, std::string &res) const {
    for (const auto &i : _data) {
      if (i.key == key) {
        rdvalue_tostring(i.val, res);
        return true;
      }
    }
    return false;
  }

  //----------------------------------------------------------
  //! \brief Sets the value associated with a key
  /*!

     \param what the key to set
     \param val  the value to store

     <b>Notes:</b>
        - If \c val is a <tt>const char *</tt>, it will be converted
           to a \c std::string for storage.
        - If the dictionary already contains the key \c what,
          the value will be replaced.
  */
  template <typename T>
  void setVal(const std::string &what, T &val) {
    std::uint16_t key = get_key(what);
    for (auto &&data : _data) {
      if (data.key == key) {
        RDValue::cleanup_rdvalue(data.val);
        data.val = val;
        return;
      }
    }
    _data.emplace_back(key, val);
  }
  template <typename T>
  void setVal(const std::uint16_t &key, T &val) {
    for (auto &&data : _data) {
      if (data.key == key) {
        RDValue::cleanup_rdvalue(data.val);
        data.val = val;
        return;
      }
    }
    _data.emplace_back(key, val);
  }

  template <typename T>
  void setPODVal(const std::string &what, T val) {
    std::uint16_t key = get_key(what);
    for (auto &&data : _data) {
      if (data.key == key) {
        RDValue::cleanup_rdvalue(data.val);
        data.val = val;
        return;
      }
    }
    _data.emplace_back(key, val);
  }

  template <typename T>
  void setPODVal(const std::uint16_t &key, T val) {
    for (auto &&data : _data) {
      if (data.key == key) {
        RDValue::cleanup_rdvalue(data.val);
        data.val = val;
        return;
      }
    }
    _data.emplace_back(key, val);
  }

  void setVal(const std::string &what, bool val) { setPODVal(what, val); }
  void setVal(const std::uint16_t &key, bool val) { setPODVal(key, val); }

  void setVal(const std::string &what, double val) { setPODVal(what, val); }
  void setVal(const std::uint16_t &key, double val) { setPODVal(key, val); }

  void setVal(const std::string &what, float val) { setPODVal(what, val); }
  void setVal(const std::uint16_t &key, float val) { setPODVal(key, val); }

  void setVal(const std::string &what, int val) { setPODVal(what, val); }
  void setVal(const std::uint16_t &key, int val) { setPODVal(key, val); }

  void setVal(const std::string &what, unsigned int val) {
    setPODVal(what, val);
  }
  void setVal(const std::uint16_t &key, unsigned int val) {
    setPODVal(key, val);
  }

  //! \overload
  void setVal(const std::string &what, const char *val) {
    std::string h(val);
    setVal(what, h);
  }
  void setVal(const std::uint16_t &key, const char *val) {
    std::string h(val);
    setVal(key, h);
  }

  //----------------------------------------------------------
  //! \brief Clears the value associated with a particular key,
  //!     removing the key from the dictionary.
  /*!

     \param what the key to clear

  */
  void clearVal(const std::string &what) {
    std::uint16_t key = get_key(what);
    for (InternalDataType::iterator it = _data.begin(); it < _data.end(); ++it) {
      if (it->key == key) {
        RDValue::cleanup_rdvalue(it->val);
        _data.erase(it);
        return;
      }
    }
  }
  void clearVal(const std::uint16_t &key) {
    for (InternalDataType::iterator it = _data.begin(); it < _data.end(); ++it) {
      if (it->key == key) {
        RDValue::cleanup_rdvalue(it->val);
        _data.erase(it);
        return;
      }
    }
  }

  //----------------------------------------------------------
  //! \brief Clears all keys (and values) from the dictionary.
  //!
  void reset() {
    for (auto &&data : _data) {
      RDValue::cleanup_rdvalue(data.val);
    }
    InternalDataType data;
    _data.swap(data);
  }

 private:
  InternalDataType _data{};       //!< the actual dictionary


};

template <>
inline std::string Dict::getVal<std::string>(const std::string &what) const {
  std::string res;
  getVal(what, res);
  return res;
}

}  // namespace RDKit
#endif
